using CommandLine;
using Graphviz4Net;
using Graphviz4Net.Dot;
using Graphviz4Net.Graphs;
using Newtonsoft.Json;
using NuGet.ProjectModel;
using NuGet.Protocol;
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace DGVisulizer
{
    public class Options
    {

        [Option('g', "dependency graph", Required = true, HelpText = "Path of the dependency graph generated by msbuild.")]
        public string DependencyGrapthPath { get; set; }

        [Option('v' ,"graphviz bin", Required = true, HelpText = "Path of the graphviz bin folder.")]
        public string GraphvizBinPath { get; set; }

        [Option('o', "output file path", Required = true, HelpText = "Path of the output file.")]
        public string OutputFilePath { get; set; }
    }

    class Program
    {
        //https://www.jerriepelser.com/blog/analyze-dotnet-project-dependencies-part-1/
        //dotnet msbuild /t:GenerateRestoreGraphFile /p:RestoreGraphOutputPath=graph.dg
        static void Main(string[] args)
        {
            CommandLine.Parser.Default.ParseArguments<Options>(args)
                .WithParsed(GenerateGraph);


        }

        private static void GenerateGraph(Options options)
        { 
            var dependencyGraph = DependencyGraphSpec.Load(options.DependencyGrapthPath);
            var graph = new Graph<string>();
            var projectVersions = new Dictionary<string, string>();

            foreach (var project in dependencyGraph.Projects.Where(p => p.RestoreMetadata.ProjectStyle == ProjectStyle.PackageReference))
            {
                //filtering test
                if (project.Name.Contains("test", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }
                graph.AddVertex(project.Name);
                projectVersions.Add(project.Name, project.Version.ToNormalizedString());
            }

            foreach (var project in dependencyGraph.Projects.Where(p => p.RestoreMetadata.ProjectStyle == ProjectStyle.PackageReference))
            {
                //filtering test
                if (project.Name.Contains("test", StringComparison.OrdinalIgnoreCase))
                {
                    continue;
                }
                Console.WriteLine(project.Name);
                HashSet<string> dep = new HashSet<string>();
                foreach (var targetFramework in project.TargetFrameworks)
                {
                    foreach (var dependency in targetFramework.Dependencies)
                    {
                        //remove duplication
                        if (dep.Contains(dependency.Name))
                        {
                            continue;
                        }
                        dep.Add(dependency.Name);
                        if (graph.Vertices.Any(v => v == dependency.Name))
                        {
                            var notLastVersion = projectVersions[dependency.Name] != dependency.LibraryRange.VersionRange.ToShortString();
                            var attributes = new Dictionary<string, string>() { { "label", dependency.LibraryRange.VersionRange.ToShortString() } };
                            if (notLastVersion)
                            {
                                attributes.Add("color", "red");
                            }
                            else
                            {
                                attributes.Add("color", "green");
                            }
                            graph.AddEdge(new Edge<string>(project.Name, dependency.Name, attributes: attributes));
                        }
                    }
                }
            }

            var writer = new StringWriter();
            new GraphToDotConverter().Convert(writer, graph, new AttributesProvider(projectVersions));
            var graphContent = writer.GetStringBuilder().ToString().Trim();
            var dotFile = Path.ChangeExtension(options.OutputFilePath,"dot");
            File.WriteAllText(dotFile,graphContent);
            var dotExec = Path.Combine(options.GraphvizBinPath, "dot.exe");
            var arguments = $"-Tjpg {dotFile} -o {options.OutputFilePath}";
            ProcessAsyncHelper.ExecuteShellCommand(dotExec , arguments,int.MaxValue).Wait();
        }
    }

    public class AttributesProvider : IAttributesProvider
    {
        private Dictionary<string, string> versions;

        public AttributesProvider(Dictionary<string, string> versions)
        {
            this.versions = versions;
        }

        public IDictionary<string, string> GetVertexAttributes(object vertex)
        {
            var proj = vertex.ToString();
            var ver = versions[proj];
            return new Dictionary<string, string>() { { "label", vertex.ToString() + "\n" + ver } };
        }
    }

}
